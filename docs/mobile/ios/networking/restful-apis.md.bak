# RESTful API å®è·µ

æœ¬æ–‡æ¡£ä»‹ç»åœ¨iOSå¼€å‘ä¸­ä¸RESTful APIäº¤äº’çš„æœ€ä½³å®è·µï¼ŒåŒ…æ‹¬åŸºæœ¬æ¦‚å¿µã€è®¾è®¡æ¨¡å¼å’Œå®ç°æŠ€å·§ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºå¯é ã€é«˜æ•ˆçš„ç½‘ç»œé€šä¿¡å±‚ã€‚

## ç›®å½•

- [RESTful API åŸºç¡€](#restful-api-åŸºç¡€)
- [iOSä¸­çš„RESTful APIå®¢æˆ·ç«¯è®¾è®¡](#iosä¸­çš„restful-apiå®¢æˆ·ç«¯è®¾è®¡)
- [è¯·æ±‚ä¸å“åº”å°è£…](#è¯·æ±‚ä¸å“åº”å°è£…)
- [è®¤è¯ä¸æˆæƒ](#è®¤è¯ä¸æˆæƒ)
- [é”™è¯¯å¤„ç†ç­–ç•¥](#é”™è¯¯å¤„ç†ç­–ç•¥)
- [ç¼“å­˜æœºåˆ¶](#ç¼“å­˜æœºåˆ¶)
- [APIç‰ˆæœ¬æ§åˆ¶](#apiç‰ˆæœ¬æ§åˆ¶)
- [å¹¶å‘å’Œé˜Ÿåˆ—ç®¡ç†](#å¹¶å‘å’Œé˜Ÿåˆ—ç®¡ç†)
- [Mockä¸æµ‹è¯•](#mockä¸æµ‹è¯•)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [å®‰å…¨æœ€ä½³å®è·µ](#å®‰å…¨æœ€ä½³å®è·µ)
- [ç»Ÿä¸€æ¥å£è®¾è®¡](#ç»Ÿä¸€æ¥å£è®¾è®¡)
- [åˆ†é¡µå’Œæ•°æ®ç­›é€‰](#åˆ†é¡µå’Œæ•°æ®ç­›é€‰)
- [å®é™…æ¡ˆä¾‹](#å®é™…æ¡ˆä¾‹)
- [APIæ–‡æ¡£åŒ–](#apiæ–‡æ¡£åŒ–)
- [å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ](#å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ)

## RESTful API åŸºç¡€

### ä»€ä¹ˆæ˜¯RESTful API?

REST (Representational State Transfer) æ˜¯ä¸€ç§è½¯ä»¶æ¶æ„é£æ ¼ï¼Œå®šä¹‰äº†ä¸€ç»„åˆ›å»ºWebæœåŠ¡çš„çº¦æŸå’Œå±æ€§ã€‚RESTful API æ˜¯éµå¾ªRESTè®¾è®¡åŸåˆ™çš„åº”ç”¨ç¨‹åºæ¥å£ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

- **èµ„æºå¯¼å‘**ï¼šæ‰€æœ‰å†…å®¹éƒ½è¢«è§†ä¸ºèµ„æºï¼Œé€šè¿‡URIå”¯ä¸€æ ‡è¯†
- **HTTPæ–¹æ³•æ˜ å°„**ï¼šä½¿ç”¨æ ‡å‡†HTTPæ–¹æ³•è¡¨ç¤ºæ“ä½œ
- **æ— çŠ¶æ€**ï¼šæœåŠ¡å™¨ä¸å­˜å‚¨å®¢æˆ·ç«¯çŠ¶æ€
- **ç»Ÿä¸€æ¥å£**ï¼šç®€åŒ–æ•´ä½“æ¶æ„ï¼Œæé«˜äº¤äº’å¯è§æ€§
- **åˆ†å±‚ç³»ç»Ÿ**ï¼šå®¢æˆ·ç«¯æ— æ³•åŒºåˆ†æ˜¯ä¸æœ€ç»ˆæœåŠ¡å™¨è¿˜æ˜¯ä¸­é—´æœåŠ¡å™¨é€šä¿¡

### RESTåŸåˆ™ä¸HTTPæ–¹æ³•

REST APIä½¿ç”¨æ ‡å‡†HTTPæ–¹æ³•æ‰§è¡Œå¯¹èµ„æºçš„æ“ä½œï¼š

| HTTPæ–¹æ³• | CRUDæ“ä½œ | æè¿° | æ˜¯å¦å¹‚ç­‰ |
|---------|---------|------|---------|
| GET | è¯»å– (Read) | è·å–èµ„æºï¼Œä¸åº”äº§ç”Ÿå‰¯ä½œç”¨ | æ˜¯ |
| POST | åˆ›å»º (Create) | åˆ›å»ºæ–°èµ„æº | å¦ |
| PUT | æ›´æ–° (Update) | å®Œå…¨æ›¿æ¢ç°æœ‰èµ„æº | æ˜¯ |
| PATCH | æ›´æ–° (Update) | éƒ¨åˆ†æ›´æ–°ç°æœ‰èµ„æº | æ˜¯ |
| DELETE | åˆ é™¤ (Delete) | åˆ é™¤èµ„æº | æ˜¯ |

> **å¹‚ç­‰**ï¼šå¤šæ¬¡é‡å¤æ‰§è¡Œç›¸åŒçš„è¯·æ±‚ï¼Œç»“æœåº”è¯¥ä¸æ‰§è¡Œä¸€æ¬¡çš„ç»“æœç›¸åŒã€‚

### RESTèµ„æºè®¾è®¡

èµ„æºæ˜¯RESTæ¶æ„çš„æ ¸å¿ƒï¼Œé€šå¸¸è¡¨ç¤ºä¸ºåè¯è€ŒéåŠ¨è¯ï¼š

```
# è‰¯å¥½çš„èµ„æºURIè®¾è®¡
GET /users          # è·å–ç”¨æˆ·åˆ—è¡¨
GET /users/123      # è·å–ç‰¹å®šç”¨æˆ·
POST /users         # åˆ›å»ºç”¨æˆ·
PUT /users/123      # æ›´æ–°ç”¨æˆ·
DELETE /users/123   # åˆ é™¤ç”¨æˆ·

# ä¸æ¨èçš„è®¾è®¡ï¼ˆä½¿ç”¨åŠ¨è¯ï¼‰
GET /getUsers
POST /createUser
PUT /updateUser/123
```

### çŠ¶æ€ç ä½¿ç”¨

RESTful APIä½¿ç”¨æ ‡å‡†HTTPçŠ¶æ€ç è¡¨ç¤ºè¯·æ±‚ç»“æœï¼š

- **2xx**ï¼šæˆåŠŸ
  - 200 OKï¼šè¯·æ±‚æˆåŠŸ
  - 201 Createdï¼šèµ„æºåˆ›å»ºæˆåŠŸ
  - 204 No Contentï¼šæˆåŠŸä½†æ— è¿”å›å†…å®¹
  
- **3xx**ï¼šé‡å®šå‘
  - 304 Not Modifiedï¼šèµ„æºæœªå˜åŒ–ï¼ˆé…åˆç¼“å­˜ï¼‰
  
- **4xx**ï¼šå®¢æˆ·ç«¯é”™è¯¯
  - 400 Bad Requestï¼šè¯·æ±‚æ ¼å¼é”™è¯¯
  - 401 Unauthorizedï¼šæœªæä¾›è®¤è¯æˆ–è®¤è¯æ— æ•ˆ
  - 403 Forbiddenï¼šæ— æƒè®¿é—®èµ„æº
  - 404 Not Foundï¼šèµ„æºä¸å­˜åœ¨
  - 422 Unprocessable Entityï¼šè¯·æ±‚æ ¼å¼æ­£ç¡®ä½†è¯­ä¹‰é”™è¯¯
  
- **5xx**ï¼šæœåŠ¡å™¨é”™è¯¯
  - 500 Internal Server Errorï¼šæœåŠ¡å™¨å†…éƒ¨é”™è¯¯
  - 503 Service Unavailableï¼šæœåŠ¡æš‚æ—¶ä¸å¯ç”¨

### æ•°æ®æ ¼å¼ä¸å†…å®¹åå•†

RESTful APIé€šå¸¸ä½¿ç”¨JSONä½œä¸ºæ•°æ®äº¤æ¢æ ¼å¼ï¼Œé€šè¿‡HTTPå¤´éƒ¨è¿›è¡Œå†…å®¹åå•†ï¼š

```
# è¯·æ±‚ç‰¹å®šæ ¼å¼çš„æ•°æ®
Accept: application/json

# æŒ‡å®šå‘é€çš„æ•°æ®æ ¼å¼
Content-Type: application/json
```

ç¤ºä¾‹JSONå“åº”ï¼š

```json
{
  "id": 123,
  "name": "å¼ ä¸‰",
  "email": "zhangsan@example.com",
  "createdAt": "2023-05-15T08:30:00Z",
  "links": {
    "self": "/users/123",
    "posts": "/users/123/posts"
  }
}
```

### HATEOAS

HATEOAS (Hypermedia as the Engine of Application State) æ˜¯RESTçš„ä¸€ä¸ªçº¦æŸï¼Œé€šè¿‡åœ¨å“åº”ä¸­åŒ…å«ç›¸å…³èµ„æºçš„é“¾æ¥ï¼Œä½¿å®¢æˆ·ç«¯å¯ä»¥åŠ¨æ€å‘ç°å¯ç”¨æ“ä½œï¼š

```json
{
  "id": 123,
  "name": "å¼ ä¸‰",
  "_links": {
    "self": { "href": "/users/123" },
    "posts": { "href": "/users/123/posts" },
    "follow": { "href": "/users/123/follow" }
  }
}
```

## iOSä¸­çš„RESTful APIå®¢æˆ·ç«¯è®¾è®¡

è®¾è®¡è‰¯å¥½çš„iOS APIå®¢æˆ·ç«¯åº”è¯¥å…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **æŠ½è±¡ä¸å°è£…**ï¼šéšè—ç½‘ç»œç»†èŠ‚ï¼Œæä¾›ç®€æ´æ¥å£
2. **å¯æµ‹è¯•æ€§**ï¼šæ˜“äºè¿›è¡Œå•å…ƒæµ‹è¯•å’Œæ¨¡æ‹Ÿ
3. **é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€ã€ä¼˜é›…çš„é”™è¯¯å¤„ç†æœºåˆ¶
4. **å¯æ‰©å±•æ€§**ï¼šæ˜“äºæ·»åŠ æ–°çš„APIç«¯ç‚¹
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ã€å¹¶å‘ã€é˜Ÿåˆ—ç®¡ç†

### å…¸å‹çš„APIå®¢æˆ·ç«¯æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è§†å›¾æ§åˆ¶å™¨    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚  ä½¿ç”¨
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API æœåŠ¡å±‚    â”‚ ä½¿ç”¨ â”‚   è¯·æ±‚æ„å»ºå™¨    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚  ä½¿ç”¨
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç½‘ç»œå±‚æŠ½è±¡    â”‚ ä½¿ç”¨ â”‚  å“åº”åºåˆ—åŒ–å™¨   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚  ä½¿ç”¨
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ URLSession/Alamofire â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åŸºæœ¬æ¶æ„ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŸºæœ¬çš„RESTful APIå®¢æˆ·ç«¯æ¶æ„ç¤ºä¾‹ï¼š

```swift
// 1. APIé”™è¯¯å®šä¹‰
enum APIError: Error {
    case invalidURL
    case requestFailed(Error)
    case invalidResponse
    case decodingFailed
    case serverError(statusCode: Int, message: String)
    case unauthorized
    case notFound
    case validationFailed([String: String])
    case networkError
    
    var errorMessage: String {
        switch self {
        case .invalidURL:
            return "æ— æ•ˆçš„URL"
        case .requestFailed(let error):
            return "è¯·æ±‚å¤±è´¥: \(error.localizedDescription)"
        case .invalidResponse:
            return "æ— æ•ˆçš„æœåŠ¡å™¨å“åº”"
        case .decodingFailed:
            return "è§£æå“åº”æ•°æ®å¤±è´¥"
        case .serverError(_, let message):
            return "æœåŠ¡å™¨é”™è¯¯: \(message)"
        case .unauthorized:
            return "æœªæˆæƒï¼Œè¯·é‡æ–°ç™»å½•"
        case .notFound:
            return "è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨"
        case .validationFailed(let errors):
            let messages = errors.map { "\($0.key): \($0.value)" }.joined(separator: ", ")
            return "éªŒè¯å¤±è´¥: \(messages)"
        case .networkError:
            return "ç½‘ç»œè¿æ¥é”™è¯¯"
        }
    }
}

// 2. APIå“åº”åŒ…è£…
struct APIResponse<T: Decodable>: Decodable {
    let data: T?
    let meta: Meta?
    let errors: [String: String]?
    
    struct Meta: Decodable {
        let status: Int
        let message: String?
        let pagination: Pagination?
    }
    
    struct Pagination: Decodable {
        let total: Int
        let count: Int
        let perPage: Int
        let currentPage: Int
        let totalPages: Int
        
        enum CodingKeys: String, CodingKey {
            case total, count
            case perPage = "per_page"
            case currentPage = "current_page"
            case totalPages = "total_pages"
        }
    }
}

// 3. ç½‘ç»œæœåŠ¡åè®®
protocol NetworkServiceProtocol {
    func request<T: Decodable>(
        url: URL,
        method: HTTPMethod,
        headers: [String: String]?,
        parameters: [String: Any]?,
        completion: @escaping (Result<T, APIError>) -> Void
    )
}

// 4. APIåŸºç¡€URLå’Œè·¯å¾„
enum APIConstants {
    static let baseURL = "https://api.example.com/v1"
    
    enum Path {
        static let users = "/users"
        static let posts = "/posts"
        static let auth = "/auth"
        
        static func user(_ id: Int) -> String {
            return "\(users)/\(id)"
        }
        
        static func userPosts(_ userId: Int) -> String {
            return "\(user(userId))/posts"
        }
    }
}

// 5. HTTPæ–¹æ³•æšä¸¾
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case patch = "PATCH"
    case delete = "DELETE"
}
```

### åŸºäºURLSessionçš„å®ç°

ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨URLSessionçš„åŸºæœ¬å®ç°ï¼š

```swift
class URLSessionNetworkService: NetworkServiceProtocol {
    private let session: URLSession
    private let decoder: JSONDecoder
    
    init(session: URLSession = .shared, decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
        
        // é…ç½®è§£ç å™¨
        self.decoder.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder.dateDecodingStrategy = .iso8601
    }
    
    func request<T: Decodable>(
        url: URL,
        method: HTTPMethod,
        headers: [String: String]?,
        parameters: [String: Any]?,
        completion: @escaping (Result<T, APIError>) -> Void
    ) {
        // åˆ›å»ºè¯·æ±‚
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        
        // æ·»åŠ å¤´éƒ¨
        headers?.forEach { request.addValue($0.value, forHTTPHeaderField: $0.key) }
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        
        // æ·»åŠ å‚æ•°
        if let parameters = parameters {
            if method == .get {
                // GETå‚æ•°ä½œä¸ºæŸ¥è¯¢å­—ç¬¦ä¸²
                var components = URLComponents(url: url, resolvingAgainstBaseURL: true)!
                components.queryItems = parameters.map { 
                    URLQueryItem(name: $0.key, value: "\($0.value)") 
                }
                request.url = components.url
            } else {
                // å…¶ä»–æ–¹æ³•ä½¿ç”¨JSON body
                request.addValue("application/json", forHTTPHeaderField: "Content-Type")
                request.httpBody = try? JSONSerialization.data(withJSONObject: parameters)
            }
        }
        
        // åˆ›å»ºä»»åŠ¡
        let task = session.dataTask(with: request) { [weak self] data, response, error in
            guard let self = self else { return }
            
            // å¤„ç†é”™è¯¯
            if let error = error {
                completion(.failure(.requestFailed(error)))
                return
            }
            
            // æ£€æŸ¥å“åº”
            guard let httpResponse = response as? HTTPURLResponse else {
                completion(.failure(.invalidResponse))
                return
            }
            
            // å¤„ç†HTTPçŠ¶æ€ç 
            switch httpResponse.statusCode {
            case 200...299:
                // æˆåŠŸå“åº”
                guard let data = data else {
                    completion(.failure(.invalidResponse))
                    return
                }
                
                // è§£æå“åº”
                do {
                    let decodedObject = try self.decoder.decode(APIResponse<T>.self, from: data)
                    
                    if let data = decodedObject.data {
                        completion(.success(data))
                    } else if let errors = decodedObject.errors {
                        completion(.failure(.validationFailed(errors)))
                    } else {
                        completion(.failure(.invalidResponse))
                    }
                } catch {
                    print("è§£ç é”™è¯¯: \(error)")
                    completion(.failure(.decodingFailed))
                }
                
            case 401:
                completion(.failure(.unauthorized))
            case 404:
                completion(.failure(.notFound))
            case 422:
                // éªŒè¯é”™è¯¯ï¼Œå°è¯•è§£æé”™è¯¯è¯¦æƒ…
                if let data = data,
                   let errorResponse = try? JSONDecoder().decode([String: [String]].self, from: data),
                   let firstErrors = errorResponse.mapValues({ $0.first }) as? [String: String] {
                    completion(.failure(.validationFailed(firstErrors)))
                } else {
                    completion(.failure(.validationFailed(["validation": "è¯·æ±‚éªŒè¯å¤±è´¥"])))
                }
            case 500...599:
                // æœåŠ¡å™¨é”™è¯¯
                if let data = data,
                   let errorResponse = try? JSONDecoder().decode([String: String].self, from: data),
                   let message = errorResponse["message"] {
                    completion(.failure(.serverError(statusCode: httpResponse.statusCode, message: message)))
                } else {
                    completion(.failure(.serverError(statusCode: httpResponse.statusCode, message: "æœåŠ¡å™¨é”™è¯¯")))
                }
            default:
                completion(.failure(.invalidResponse))
            }
        }
        
        // å¯åŠ¨è¯·æ±‚
        task.resume()
    }
}
```

### åŸºäºAlamofireçš„å®ç°

å¦‚æœä½¿ç”¨Alamofireï¼Œå¯ä»¥ç®€åŒ–ç½‘ç»œå±‚å®ç°ï¼š

```swift
import Alamofire

class AlamofireNetworkService: NetworkServiceProtocol {
    private let session: Session
    private let decoder: JSONDecoder
    
    init(session: Session = .default, decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
        
        // é…ç½®è§£ç å™¨
        self.decoder.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder.dateDecodingStrategy = .iso8601
    }
    
    func request<T: Decodable>(
        url: URL,
        method: HTTPMethod,
        headers: [String: String]?,
        parameters: [String: Any]?,
        completion: @escaping (Result<T, APIError>) -> Void
    ) {
        // è½¬æ¢HTTPæ–¹æ³•
        let afMethod = Alamofire.HTTPMethod(rawValue: method.rawValue)
        
        // åˆ›å»ºè¯·æ±‚å¤´
        var headerDict = HTTPHeaders()
        headers?.forEach { headerDict.add(name: $0.key, value: $0.value) }
        
        // ç¡®å®šç¼–ç æ–¹å¼
        let encoding: ParameterEncoding = method == .get ? URLEncoding.default : JSONEncoding.default
        
        // åˆ›å»ºè¯·æ±‚
        session.request(
            url,
            method: afMethod,
            parameters: parameters,
            encoding: encoding,
            headers: headerDict
        )
        .validate()
        .responseDecodable(of: APIResponse<T>.self, decoder: decoder) { response in
            switch response.result {
            case .success(let apiResponse):
                if let data = apiResponse.data {
                    completion(.success(data))
                } else if let errors = apiResponse.errors {
                    completion(.failure(.validationFailed(errors)))
                } else {
                    completion(.failure(.invalidResponse))
                }
                
            case .failure(let error):
                // è½¬æ¢Alamofireé”™è¯¯
                if let afError = error.asAFError {
                    switch afError {
                    case .responseValidationFailed(let reason):
                        if case .unacceptableStatusCode(let code) = reason {
                            switch code {
                            case 401:
                                completion(.failure(.unauthorized))
                            case 404:
                                completion(.failure(.notFound))
                            case 422:
                                // å°è¯•è§£æéªŒè¯é”™è¯¯
                                if let data = response.data,
                                   let errorResponse = try? JSONDecoder().decode([String: [String]].self, from: data),
                                   let firstErrors = errorResponse.mapValues({ $0.first }) as? [String: String] {
                                    completion(.failure(.validationFailed(firstErrors)))
                                } else {
                                    completion(.failure(.validationFailed(["validation": "è¯·æ±‚éªŒè¯å¤±è´¥"])))
                                }
                            case 500...599:
                                if let data = response.data,
                                   let errorResponse = try? JSONDecoder().decode([String: String].self, from: data),
                                   let message = errorResponse["message"] {
                                    completion(.failure(.serverError(statusCode: code, message: message)))
                                } else {
                                    completion(.failure(.serverError(statusCode: code, message: "æœåŠ¡å™¨é”™è¯¯")))
                                }
                            default:
                                completion(.failure(.invalidResponse))
                            }
                        } else {
                            completion(.failure(.invalidResponse))
                        }
                    case .responseSerializationFailed:
                        completion(.failure(.decodingFailed))
                    case .sessionTaskFailed(let error):
                        if let urlError = error as? URLError {
                            if urlError.code == .notConnectedToInternet || urlError.code == .networkConnectionLost {
                                completion(.failure(.networkError))
                            } else {
                                completion(.failure(.requestFailed(error)))
                            }
                        } else {
                            completion(.failure(.requestFailed(error)))
                        }
                    default:
                        completion(.failure(.requestFailed(error)))
                    }
                } else {
                    completion(.failure(.requestFailed(error)))
                }
            }
        }
    }
}
``` # #   M o c k NKmÕ‹\ n \ n KmÕ‹QÜ~B\/f„gú^ïS`—A P I ¢[7bïz„vsQ.•èR0 
 