# C 语言：内存管理

C 语言赋予了程序员直接管理内存的强大能力，这既是其高性能的源泉，也是许多错误的根源。理解 C 语言的内存模型是编写健壮、高效程序的关键。

计算机程序的内存主要分为三个区域：

1.  **静态/全局内存区 (Static/Global Memory)**：用于存储全局变量和静态变量。这部分内存在程序启动时分配，在程序结束时释放。
2.  **栈区 (The Stack)**：用于存储函数参数、局部变量。栈上的内存分配和释放是自动管理的，遵循"后进先出"(LIFO) 的原则。当函数被调用时，其变量在栈上创建；当函数返回时，这些变量被自动销毁。它的空间有限，分配速度快。
3.  **堆区 (The Heap)**：这是一块可供程序员在程序运行时**动态**请求和释放的内存区域。堆内存的大小只受限于可用的物理内存和虚拟内存空间，但其分配和释放必须由程序员**手动管理**。

本章重点讨论**堆内存**的管理，即**动态内存分配**。

## 1. 动态内存分配

有时，我们在编写程序时并不知道需要多少内存。例如，程序需要读取一个用户指定大小的文件，或者创建一个大小不定的数组。在这种情况下，我们就需要在程序运行时从堆上请求所需大小的内存。

C 标准库 `<stdlib.h>` 提供了几个核心函数来管理动态内存。

### `malloc()` - 分配内存

`malloc` (memory allocation) 函数用于从堆上分配指定字节数的内存。

**原型:**
`void* malloc(size_t size);`

- **参数 `size`**: 需要分配的内存大小（以字节为单位）。
- **返回值**:
    - 如果成功，返回一个指向所分配内存块起始位置的 `void*` 类型的指针。`void*` 是一个通用指针，可以被转换成任何类型的指针。
    - 如果失败（例如，内存不足），返回 `NULL`。

**使用 `malloc` 的关键步骤:**
1.  调用 `malloc` 请求内存，通常与 `sizeof` 结合使用以确保可移植性。
2.  **必须检查** `malloc` 的返回值是否为 `NULL`。
3.  将返回的 `void*` 指针**强制类型转换**为你需要的指针类型。
4.  使用完内存后，**必须调用 `free()`** 来释放它。

**示例：动态创建一个整数数组**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 5;
    int* arr;

    // 分配能存储 5 个整数的内存空间
    arr = (int*) malloc(n * sizeof(int));

    // 检查 malloc 是否成功
    if (arr == NULL) {
        printf("内存分配失败！\n");
        return 1; // 返回错误码
    }

    // 像普通数组一样使用它
    for (int i = 0; i < n; i++) {
        arr[i] = i + 1;
        printf("%d ", arr[i]);
    }
    printf("\n");

    // TODO: 释放内存
    
    return 0;
}
```

### `free()` - 释放内存

动态分配的内存**不会**自动释放。如果你分配了内存但忘记释放，就会发生**内存泄漏 (Memory Leak)** —— 程序占用的内存越来越多，最终可能导致系统资源耗尽而崩溃。

`free()` 函数用于将之前通过 `malloc`, `calloc`, `realloc` 分配的内存返还给堆，使其可以被再次使用。

**原型:**
`void free(void* ptr);`

- **参数 `ptr`**: 指向要释放的内存块的指针。

**重要规则:**
- **有借有还**: 每个 `malloc` 都必须有一个对应的 `free`。
- **不要重复释放**: 对同一个指针调用两次 `free` 会导致未定义行为。
- **不要释放栈内存或未分配的指针**: `free` 只能用于堆上分配的内存。
- **释放后设为 NULL**: 释放指针后，该指针本身的值并没有改变，它仍然指向原来的（现在已无效的）内存地址，成为一个**悬空指针 (Dangling Pointer)**。解引用悬空指针同样是危险的。一个好的实践是在 `free` 之后立即将指针设为 `NULL`。

**示例（续）:**
```c
// ... 使用完 arr 后 ...

// 释放内存
free(arr);

// 将指针设为 NULL，防止成为悬空指针
arr = NULL; 
```

### `calloc()` - 分配并清零内存

`calloc` (contiguous allocation) 函数与 `malloc` 类似，但有两个主要区别：
1.  它接受两个参数：元素的数量和每个元素的大小。
2.  它会将分配的内存块中的所有字节都**初始化为 0**。

**原型:**
`void* calloc(size_t num, size_t size);`

**示例:**
```c
// 分配 10 个整数的空间，并保证所有位都为 0
int* safe_arr = (int*) calloc(10, sizeof(int));
```

### `realloc()` - 重新分配内存

`realloc` (re-allocation) 函数用于调整之前已分配内存块的大小。它可以扩大或缩小内存块。

**原型:**
`void* realloc(void* ptr, size_t new_size);`

- **`ptr`**: 指向先前分配的内存块的指针。
- **`new_size`**: 新的内存大小（以字节为单位）。

`realloc` 的行为比较复杂：
- 如果是在原地扩大内存，它会返回与 `ptr` 相同的地址。
- 如果原地空间不足，它会在堆上寻找一个新的、足够大的内存块，将旧内存块的内容**复制**到新块中，**释放**旧块，然后返回新块的地址。
- 如果 `realloc` 失败，它会返回 `NULL`，并且**原始的内存块 `ptr` 不会被释放**。

**示例：动态扩展数组**
```c
int* arr = (int*) malloc(5 * sizeof(int));
// ... 使用 arr ...

// 尝试将数组大小扩展到 10 个整数
int* new_arr = (int*) realloc(arr, 10 * sizeof(int));

if (new_arr == NULL) {
    printf("内存重分配失败！\n");
    free(arr); // 即使 realloc 失败，也要释放原来的内存
    return 1;
}

// 从现在起，应该使用 new_arr
arr = new_arr; 
```

---

手动内存管理是 C 语言强大但需要负责任使用的特性。正确地处理动态内存是避免程序崩溃和资源泄漏的关键。接下来，我们将学习如何与外部文件进行交互：[C 语言文件操作](c-file-io.md)。 