# Rust 系统编程

系统编程是 Rust 的核心优势领域。它涉及开发底层软件，如操作系统、设备驱动程序、文件系统和网络协议栈等。Rust 的设计目标——安全性、并发性和性能——使其成为现代系统编程的理想选择，它能够在不牺牲性能的前提下，提供与 C/C++ 相媲美的底层控制能力，同时通过其所有权和类型系统在编译时消除大量的常见错误。

## 1. 为什么选择 Rust 进行系统编程？

- **内存安全**: Rust 的所有权和借用检查器在编译时就消除了空指针、悬垂指针和数据竞争等问题，这在系统级软件中至关重要。
- **零成本抽象**: 特质、闭包、泛型等高级语言特性在编译后会被优化成高效的机器码，几乎没有运行时开销。
- **强大的并发模型**: `Send` 和 `Sync` 特质使得编写安全的并发代码变得容易，能够充分利用现代多核处理器的性能。
- **底层控制能力**: Rust 允许直接进行内存操作（在 `unsafe` 块中）、精确的内存布局控制以及与硬件的低级交互。
- **与 C 的互操作性**: 通过 FFI，Rust 可以轻松地与现有的 C 库和系统 API 集成。
- **无运行时/垃圾回收**: Rust 不需要一个庞大的运行时或垃圾回收器，这使得它非常适合资源受限的环境和对性能要求极高的场景。

## 2. 核心概念与工具

### 2.1. `unsafe` Rust

虽然 Rust 的安全检查非常强大，但在系统编程中，有时必须执行一些编译器无法保证安全的操作，例如：
- 解引用裸指针 (`*const T`, `*mut T`)。
- 调用 `unsafe` 函数（特别是通过 FFI 调用外部函数）。
- 实现 `unsafe` 特质。
- 访问或修改可变的静态变量。

这些操作必须在 `unsafe` 代码块或函数中进行。`unsafe` 并不意味着关闭 Rust 的所有安全检查，它只是允许你执行上述几种特定的不安全操作。使用 `unsafe` 关键字是你向编译器保证，你已经确保了这段代码的安全性。

```rust
fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        *r2 = 6;
        println!("num is now: {}", num);
    }
}
```

### 2.2. 数据布局控制

`#[repr(...)]` 属性允许你控制结构体、枚举和联合体在内存中的布局方式。

- **`#[repr(C)]`**:
  - 这是进行 FFI 和系统编程时最常用的表示。
  - 它保证了字段的排列顺序与在 C 代码中声明的顺序一致，并且遵循平台的 C ABI 布局规则。
  - 这对于创建与 C 库或操作系统 API 兼容的数据结构至关重要。

```rust
#[repr(C)]
struct MySystemData {
    id: u32,
    status: u8,
    config: u16,
}
```

- **`#[repr(packed)]`**:
  - 移除字段之间的内存对齐填充。
  - 这在需要精确控制内存布局以匹配硬件或网络协议的特定格式时非常有用。
  - **警告**: 访问未对齐的字段可能会导致性能下降，甚至在某些架构上引发错误，通常需要与裸指针一起在 `unsafe` 块中使用。

### 2.3. 裸指针 (`*const T` 和 `*mut T`)

裸指针是 Rust 中最接近 C/C++ 指针的概念。它们：
- 可以是空指针。
- 不保证指向有效的内存。
- 不遵循借用规则，你可以拥有任意数量的可变或不可变裸指针。
- 解引用它们是不安全的操作。

裸指针常用于 FFI、与硬件交互或构建底层数据结构。

### 2.4. 内联汇编 (`asm!`)

对于需要极致性能或直接与硬件指令交互的场景，Rust 提供了 `asm!` 和 `global_asm!` 宏来嵌入内联汇编代码。

```rust
use std::arch::asm;

fn add(a: i32, b: i32) -> i32 {
    let mut c: i32;
    unsafe {
        asm!(
            "add {0}, {1}",
            inout(reg) a => c,
            in(reg) b,
        );
    }
    c
}
```
**注意**: 内联汇编非常复杂，且依赖于特定的 CPU 架构，应谨慎使用。

## 3. 实践领域

### 3.1. 操作系统开发

- **`#[no_std]`**:
  - `#[no_std]` 属性允许你编写不链接标准库 `std` 的 Rust 代码。
  - 标准库依赖于操作系统提供的功能（如内存分配、文件系统、网络）。在开发操作系统或嵌入式应用时，这些功能尚不存在。
  - 使用 `#[no_std]` 时，你只能依赖核心库 `core`，它提供了与硬件无关的基本类型和原语。

- **启动和入口点**:
  - 你需要使用 `#[panic_handler]` 属性定义一个恐慌处理器。
  - 使用 `#[no_mangle]` 和 `extern "C"` 来定义一个操作系统加载器可以识别的入口点，并禁用 `main` 函数。

- **内存管理**:
  - 在 `#[no_std]` 环境中，你需要自己实现或引入一个全局内存分配器。

- **相关项目**: Redleaf, Redox, Tock.

### 3.2. 网络编程

- Rust 的高性能和并发安全性使其非常适合编写网络协议、数据包处理器和高性能服务器。
- 像 `smoltcp` 这样的库允许你在没有操作系统支持的情况下（`#[no_std]`）实现一个完整的 TCP/IP 协议栈。

### 3.3. 文件系统

- 构建自定义的文件系统或与现有文件系统进行底层交互也是系统编程的一部分。
- Rust 的强类型系统可以帮助你精确地建模文件系统的元数据和数据结构。

## 总结

Rust 为系统编程带来了革命性的变化。它在保持对底层硬件和内存的精细控制能力的同时，通过编译时安全检查消除了困扰 C/C++ 开发者数十年的诸多问题。
- **`unsafe`** 和**裸指针**提供了必要的底层访问能力。
- **`#[repr(C)]`** 确保了与现有系统 API 的兼容性。
- **`#[no_std]`** 使得 Rust 可以用于开发操作系统和嵌入式系统。
- **FFI** 无缝集成了庞大的 C 生态系统。

对于追求性能、可靠性和安全性的系统级软件开发，Rust 无疑是一个顶级的选择。 