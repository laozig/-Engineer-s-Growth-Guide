# 11. Apache Cassandra

Apache Cassandra 是一个开源的、分布式的、宽列存储（Wide-Column Store）NoSQL数据库。它的设计目标是处理分布在大量商用服务器上的海量数据集，并提供持续的可用性、线性的扩展性和无单点故障的架构。

Cassandra 最初由Facebook开发，用于收件箱搜索功能，其设计深受Amazon DynamoDB论文的影响。因此，Cassandra在很多方面都像是DynamoDB核心思想的一个开源实现和演进。

## Cassandra 架构

Cassandra的架构是完全**去中心化**的，遵循对等（Peer-to-Peer）模型。

- **无主架构 (Masterless)**: 集群中没有主节点（Master）。所有的节点都是对等的，每个节点都可以处理任何客户端的读写请求。这彻底消除了单点故障。
- **Gossip协议**: 节点之间通过Gossip协议来发现彼此、交换位置和状态信息，维护集群成员关系。
- **分区与复制**:
  - Cassandra使用**一致性哈希**来将数据分布在节点组成的"环"上。
  - 和Dynamo一样，它也使用**虚拟节点 (vnodes)**来保证数据分布的均匀性和负载均衡。
  - 数据通过**副本因子 (Replication Factor)**来定义复制的数量，并通过**副本放置策略**来决定副本如何跨越数据中心和机架，以实现高可用和容灾。

![Cassandra Architecture](https://miro.medium.com/v2/resize:fit:1200/1*K-d28xY6Yy2o_N2u5g_Akw.png)
*(图片来源: Medium)*

## 数据模型

Cassandra是一个宽列存储数据库，其数据模型比简单的键值存储更丰富。

- **Keyspace (键空间)**: 类似于关系数据库中的`database`，是表的容器。
- **Table (表)**: 类似于关系数据库中的`table`，但没有严格的模式。
- **Row (行)**: 由一个唯一的**主键 (Primary Key)**来标识。
- **Column (列)**: 每行可以有任意数量的列。

**主键 (Primary Key)** 是理解Cassandra数据模型和查询方式的关键。它由两部分组成：
1.  **分区键 (Partition Key)**:
    - **必须提供**。Cassandra对分区键进行哈希计算，以决定这行数据存储在哪个节点上。
    - **所有具有相同分区键的行，都会被存储在同一个节点上**。这使得针对单个分区的查询非常高效。
2.  **聚类键 (Clustering Key)**:
    - **可选**。它决定了在一个分区内部，数据行是如何**物理排序**的。
    - 这使得你可以对一个分区内的数据进行高效的范围查询（例如，获取某个用户最近的100条消息）。

> **查询哲学**: Cassandra的设计哲学是"为查询而建模"。你必须根据你的查询模式来设计表的主键，而不是像关系数据库那样先设计表再随意查询。**所有查询都必须在WHERE子句中提供完整的分区键**。

## 读写路径

Cassandra的读写路径与Dynamo非常相似，并进行了一些重要的优化。

### 写路径

1.  客户端向集群中的**任意节点**（协调者/Coordinator）发送写请求。
2.  协调者根据分区键计算出该数据应该存储在哪些副本节点上。
3.  协调者将写操作发送给所有的副本节点。
4.  副本节点收到写请求后，执行两个关键操作：
    - **写入Commit Log**: 这是一个仅追加的日志文件，用于持久化，保证节点崩溃后数据不丢失。
    - **写入Memtable**: 这是一个内存中的数据结构（通常是排序树），用于缓存写操作。
5.  一旦数据写入Commit Log和Memtable，副本节点就向协调者返回成功确认。
6.  协调者等待，直到收到来自指定数量（由**一致性级别/Consistency Level**决定）的副本的确认后，就向客户端返回成功。

这个过程非常快，因为它只涉及内存写入和顺序的磁盘追加。

- **从Memtable到SSTable**: 当Memtable达到一定大小时，它会被刷新（Flush）到磁盘上，成为一个**SSTable (Sorted String Table)**。SSTable是**不可变**的。

### 读路径

1.  客户端向任意节点（协调者）发送读请求。
2.  协调者根据分区键找到所有副本节点，并根据一致性级别向一个或多个副本发送读请求。
3.  副本节点首先在**Memtable**中查找数据，如果找到则返回。
4.  如果在Memtable中未找到，则会查询磁盘上的一系列**SSTable**。为了避免每次都扫描所有SSTable，Cassandra使用**布隆过滤器 (Bloom Filter)**来快速判断一个SSTable中是否**可能**包含所需的数据。
5.  协调者等待，直到收到来自指定数量副本的响应。
6.  **读修复 (Read Repair)**: 如果协调者发现不同副本返回的数据版本不一致，它会选择最新的版本返回给客户端，并在后台异步地将最新版本更新到持有旧数据的副本上。

## 一致性级别 (Consistency Level)

与Dynamo的NWR Quorum类似，Cassandra为每次读写操作提供了可调节的一致性级别。

- **`ONE`**: 只需一个副本确认即可。性能最高，一致性最弱。
- **`QUORUM`**: 需要大多数（N/2 + 1）副本确认。这是性能和一致性之间的常用平衡点。
- **`LOCAL_QUORUM`**: 在**当前数据中心**内，需要大多数副本确认。用于多数据中心部署。
- **`EACH_QUORUM`**: 在**每个数据中心**内，都需要大多数副本确认。
- **`ALL`**: 需要所有副本确认。性能最差，一致性最强（但仍不是线性一致性）。

通过在读写时选择不同的级别，开发者可以灵活地控制应用的性能和数据一致性。例如，`WRITE(QUORUM) + READ(QUORUM)` 可以保证强一致性（但有例外情况）。

## 优缺点

### 优点
- **极高的可用性和扩展性**: 无主架构和对等模型使其能够轻松扩展到数百个节点，并且容忍多个节点和数据中心故障。
- **出色的写性能**: 基于Commit Log和Memtable的写路径设计，使得写入吞吐量非常高。
- **灵活的数据模型**: 宽列模型比简单的键值对更具表现力。
- **可调节的一致性**: 允许开发者根据业务需求在性能和一致性之间做出权衡。

### 缺点
- **有限的查询能力**: 查询严重依赖于主键设计。不支持JOIN、聚合（有非常有限的支持）等复杂查询。
- **读性能可能成为瓶颈**: 相比于写，读操作更复杂，需要查询多个SSTable，可能涉及多次磁盘I/O。
- **最终一致性**: 需要开发者理解并处理数据最终一致性带来的复杂性。
- **运维复杂性**: 虽然比Ceph简单，但管理一个大规模的Cassandra集群（监控、修复、调优SSTable合并等）仍然需要专业知识。

Cassandra是一个功能强大、久经考验的NoSQL数据库，特别适合需要处理海量写入、高可用性、跨数据中心复制的场景，如物联网数据、时间序列数据、用户活动日志等。 