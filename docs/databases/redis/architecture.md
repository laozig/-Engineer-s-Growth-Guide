# Redis 架构

Redis 作为一个内存数据结构存储系统，拥有精心设计的架构，使其能够提供高性能、可靠性和可扩展性。本文将深入探讨 Redis 的内部架构，包括核心组件、内存管理、事件模型和集群架构。

## 目录

- [核心架构概述](#核心架构概述)
- [进程模型](#进程模型)
- [内存管理](#内存管理)
- [事件模型](#事件模型)
- [持久化架构](#持久化架构)
- [主从复制架构](#主从复制架构)
- [哨兵架构](#哨兵架构)
- [集群架构](#集群架构)
- [客户端与服务器通信](#客户端与服务器通信)

## 核心架构概述

Redis 的核心架构可以分为以下几个主要部分：

1. **服务器核心**：处理客户端请求、管理数据库和协调各组件工作
2. **数据结构**：实现各种数据类型的存储和操作
3. **持久化系统**：负责数据的持久化存储
4. **事件循环**：处理客户端连接和命令执行
5. **复制系统**：管理主从数据同步
6. **集群系统**：处理分布式数据和节点通信

Redis 采用单进程单线程模型（在 Redis 6.0 之前），通过事件驱动和非阻塞 I/O 实现高性能，同时支持主从复制、哨兵和集群模式以提供高可用性和可扩展性。

## 进程模型

### 单线程架构（Redis 6.0 之前）

Redis 的核心设计原则之一是简单性。在 Redis 6.0 之前，Redis 使用单线程模型来处理所有客户端请求，这种设计有几个关键优势：

1. **简化实现**：无需处理复杂的线程同步问题
2. **避免上下文切换开销**：不存在线程切换导致的 CPU 缓存失效
3. **消除锁的需求**：单线程模型无需使用锁，减少了相关开销

单线程模型的工作流程：

1. 客户端发送请求到服务器
2. 服务器对请求进行排队
3. 事件循环按顺序处理请求
4. 服务器将结果返回给客户端

尽管使用单线程模型，Redis 仍然能够实现极高的性能，主要是因为：
- 所有操作都在内存中执行，避免了磁盘 I/O 瓶颈
- 采用高效的数据结构和算法
- 使用非阻塞 I/O 和事件驱动模型

### 多线程 I/O（Redis 6.0+）

从 Redis 6.0 开始，Redis 引入了多线程 I/O 处理，但仍保持核心命令处理的单线程特性。这种混合模型的目的是：

1. 利用多核优势加速网络 I/O 处理
2. 保持核心逻辑的简单性和原子性

多线程 I/O 模型工作流程：

1. 主线程接受客户端连接
2. I/O 线程池负责读取客户端查询请求
3. 主线程解析并执行命令
4. I/O 线程池负责将响应写回客户端

这种设计在保持命令执行简单性的同时，显著提高了高并发场景下的性能。

## 内存管理

Redis 作为内存数据库，其内存管理机制直接影响性能和稳定性。

### 内存分配器

Redis 可以使用多种内存分配器：

1. **jemalloc**：默认分配器，提供良好的内存碎片管理和多线程性能
2. **tcmalloc**：Google 开发的高性能分配器
3. **libc malloc**：标准 C 库分配器，较少使用

### 内存回收策略

当达到内存上限时，Redis 使用配置的淘汰策略释放内存：

1. **LRU (Least Recently Used)**：移除最近最少使用的键
   - `volatile-lru`：只移除有过期时间的键
   - `allkeys-lru`：移除任何键

2. **LFU (Least Frequently Used)**（Redis 4.0+）：移除访问频率最低的键
   - `volatile-lfu`：只移除有过期时间的键
   - `allkeys-lfu`：移除任何键

3. **随机淘汰**：随机选择键移除
   - `volatile-random`：只随机移除有过期时间的键
   - `allkeys-random`：随机移除任何键

4. **TTL (Time To Live)**：移除最近将要过期的键
   - `volatile-ttl`：移除最近将要过期的键

5. **不淘汰**：
   - `noeviction`：达到内存上限时返回错误，而不是删除键

### 内存优化技术

Redis 采用多种技术来优化内存使用：

1. **共享对象池**：对于常用整数值，Redis 使用共享对象避免重复创建
2. **特殊编码**：根据数据内容自动选择最节省内存的内部编码方式
3. **压缩列表 (ziplist)**：用于小型列表、哈希和有序集合的紧凑表示
4. **整数集合 (intset)**：用于仅包含整数的小型集合
5. **RedisObject 结构**：统一管理不同类型的数据

## 事件模型

Redis 使用事件驱动架构来处理客户端请求和定时任务，这是实现高性能的关键因素之一。

### 事件循环

Redis 的事件循环基于多路复用技术（如 epoll、kqueue 或 select），能够高效地处理大量并发连接。事件循环处理两种类型的事件：

1. **文件事件**：网络 I/O 操作触发的事件
   - 连接接受事件
   - 读取命令事件
   - 回复客户端事件

2. **时间事件**：按时间触发的事件
   - 定期任务（如过期键清理）
   - 统计信息更新
   - 持久化操作

### 事件处理流程

1. 使用 I/O 多路复用监听套接字
2. 当有事件就绪时，分发给对应的处理器
3. 处理器执行具体操作并生成响应
4. 将响应添加到输出缓冲区
5. 当套接字可写时，将响应发送给客户端

### 非阻塞 I/O

Redis 使用非阻塞 I/O 操作，确保单线程能够高效处理多个连接：

- 套接字设置为非阻塞模式
- 使用 I/O 多路复用机制（如 epoll、kqueue）监控文件描述符状态变化
- 只在 I/O 操作能够立即完成时执行它们，否则将操作排队等待条件满足

## 持久化架构

Redis 提供多种持久化机制，以确保数据在服务器重启后能够恢复。

### RDB (Redis Database)

RDB 持久化通过定期创建数据库快照，将内存中的所有数据保存到磁盘文件中。

**RDB 工作流程**：

1. Redis 创建一个子进程（通过 fork）
2. 子进程将数据集写入临时 RDB 文件
3. 临时文件写入完成后，替换之前的 RDB 文件

**优势**：
- 紧凑的单一文件，便于备份和恢复
- 子进程负责持久化，不影响主进程服务
- 恢复速度快

**劣势**：
- 两次快照之间的数据可能丢失
- fork 进程需要额外内存

### AOF (Append Only File)

AOF 持久化记录服务器收到的每一条写命令，并将这些命令追加到 AOF 文件中。

**AOF 工作流程**：

1. 服务器执行写命令
2. 将命令追加到 AOF 缓冲区
3. 根据同步策略（always/everysec/no）将缓冲区内容写入并同步到 AOF 文件
4. 当 AOF 文件过大时，触发 AOF 重写以优化文件大小

**优势**：
- 更好的耐久性，支持不同级别的同步策略
- 人类可读的命令格式
- 在后台重写 AOF 文件时不会中断服务

**劣势**：
- 文件通常大于同等数据的 RDB 文件
- 根据同步策略的不同，可能比 RDB 慢

### 混合持久化（Redis 4.0+）

混合持久化结合了 RDB 和 AOF 的优点，用于 AOF 重写过程：

1. 创建子进程执行 AOF 重写
2. 子进程首先创建 RDB 格式的数据快照
3. 将快照写入 AOF 文件的开头
4. 将重写期间的增量命令追加到文件末尾

这种方式既保证了恢复速度（RDB 部分），又具有 AOF 的耐久性优势。

## 主从复制架构

Redis 通过主从复制提供数据冗余和读取扩展能力。

### 复制流程

1. **复制初始化**：
   - 从服务器发送 PSYNC 命令给主服务器
   - 第一次复制时使用完整同步，之后使用部分同步

2. **完整同步**：
   - 主服务器创建 RDB 文件
   - 将 RDB 文件发送给从服务器
   - 从服务器加载 RDB 文件重建数据集

3. **部分同步**：
   - 主服务器维护复制积压缓冲区
   - 从服务器提供复制偏移量
   - 如果偏移量在缓冲区范围内，只发送增量数据

4. **命令传播**：
   - 主服务器将写命令实时发送给从服务器
   - 从服务器执行接收到的命令

### 复制特性

1. **异步复制**：主服务器不会等待从服务器完成命令执行
2. **一主多从**：一个主服务器可以有多个从服务器
3. **链式复制**：从服务器也可以有自己的从服务器
4. **断线重连**：从服务器断线后重连时尝试部分同步

### 复制优化

1. **无盘复制**：主服务器直接通过网络发送 RDB 数据，不写入磁盘
2. **复制缓冲区大小调整**：根据网络条件和数据变化率调整复制积压缓冲区大小
3. **延迟监控**：监控主从之间的复制延迟

## 哨兵架构

Redis Sentinel（哨兵）是 Redis 的高可用性解决方案，用于监控、通知和自动故障转移。

### 哨兵工作原理

1. **监控**：
   - 定期检查主从服务器是否正常运行
   - 使用 PING 命令检测服务器响应

2. **通知**：
   - 当被监控的 Redis 实例出现问题时通知管理员或其他应用程序
   - 通过 API 或发布/订阅消息进行通知

3. **自动故障转移**：
   - 当主服务器不可用时，选择一个从服务器升级为新主服务器
   - 通知其他从服务器改变复制目标
   - 通知客户端应用程序主服务器的地址已更改

4. **配置提供者**：
   - 客户端连接到哨兵询问当前主服务器地址

### 哨兵集群

哨兵通常以集群形式部署（至少 3 个实例），通过 Raft 类似的算法达成共识：

1. **领导者选举**：
   - 当需要进行故障转移时，哨兵实例通过投票选出负责执行的领导者
   - 只有获得大多数哨兵同意的领导者才能执行故障转移

2. **石英钟**：
   - 使用多个哨兵实例共同判断主服务器状态，避免单一判断错误
   - 只有当超过配置的哨兵数量（quorum）都认为主服务器不可用时，才会启动故障转移

3. **自动发现**：
   - 哨兵通过 Redis 的发布/订阅功能自动发现其他哨兵实例
   - 哨兵通过主服务器获取从服务器信息

## 集群架构

Redis Cluster 是 Redis 的分布式解决方案，提供数据分片、自动故障转移和高可用性。

### 数据分片

Redis 集群使用哈希槽（hash slot）概念实现数据分片：

1. **哈希槽分配**：
   - 集群中总共有 16384 个哈希槽
   - 每个节点负责一部分哈希槽
   - 根据 CRC16(key) mod 16384 计算键所属的哈希槽

2. **节点路由**：
   - 客户端可以直接连接任何节点
   - 如果键不在当前节点，返回 MOVED 错误指向正确节点
   - 智能客户端会缓存槽与节点的映射关系，减少重定向

3. **槽迁移**：
   - 支持在线重新分片，将哈希槽从一个节点迁移到另一个节点
   - 迁移过程不影响集群正常工作

### 集群通信

Redis 集群节点通过两个 TCP 连接通信：

1. **集群总线**：节点间通信，用于故障检测、配置更新、故障转移授权等
   - 使用二进制协议提高效率
   - 通过 Gossip 协议传播集群状态

2. **客户端连接端口**：处理客户端请求
   - 与单机 Redis 使用相同的协议

### 集群一致性

Redis 集群提供的一致性保证：

1. **最终一致性**：复制是异步的，可能导致写后读不一致
2. **有限事务支持**：集群模式下只支持操作同一个哈希槽中键的事务
3. **故障转移选举**：使用基于 Raft 算法的复制组选举机制

## 客户端与服务器通信

Redis 客户端和服务器之间使用基于 TCP 的自定义协议通信，称为 RESP（REdis Serialization Protocol）。

### RESP 协议

RESP 是一种二进制安全的文本协议，具有以下特点：

1. **简单**：易于实现和解析
2. **高效**：优化了序列化和反序列化速度
3. **人类可读**：以文本形式表示，便于调试
4. **类型化数据**：支持不同数据类型的传输

RESP 协议定义了几种数据类型：
- 简单字符串：以 "+" 开头
- 错误：以 "-" 开头
- 整数：以 ":" 开头
- 批量字符串：以 "$" 开头
- 数组：以 "*" 开头

### 客户端连接处理

Redis 服务器处理客户端连接的流程：

1. 服务器创建监听套接字，等待客户端连接
2. 客户端与服务器建立 TCP 连接
3. 服务器为每个客户端连接创建客户端状态对象（redisClient），存储连接信息
4. 客户端发送命令请求
5. 服务器解析命令，执行操作并将结果返回给客户端

### 请求-响应模型

Redis 使用请求-响应模型处理客户端命令：

1. **客户端发送命令**：客户端通过 TCP 连接将命令发送给服务器
2. **服务器处理命令**：服务器解析并执行命令
3. **服务器返回响应**：服务器将命令执行结果返回给客户端
4. **客户端接收响应**：客户端解析服务器响应

为了提高性能，Redis 还支持流水线（pipeline）操作，允许客户端一次性发送多个命令，然后一次性接收所有响应，减少网络往返延迟。

### 发布/订阅模型

除了请求-响应模型，Redis 还支持发布/订阅模式：

1. 客户端通过 SUBSCRIBE 命令订阅一个或多个频道
2. 服务器将客户端添加到相应频道的订阅者列表
3. 当消息发布到频道时，服务器将消息推送给所有订阅该频道的客户端
4. 客户端不需要主动请求，可以持续接收消息

## 小结

Redis 的架构设计体现了简单性、高性能和灵活性的核心理念。通过单线程（或有限的多线程）模型、内存操作、高效的数据结构和事件驱动架构，Redis 实现了卓越的性能。同时，通过持久化、复制、哨兵和集群功能，Redis 提供了高可用性和可扩展性。

理解 Redis 的内部架构有助于更好地配置和使用 Redis，充分发挥其性能潜力，并设计出更合适的数据存储和访问模式。在后续章节中，我们将深入探讨 Redis 的各种数据类型和命令，以及如何在实际应用中高效使用它们。 