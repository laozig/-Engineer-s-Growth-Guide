# Redis Cluster (集群)

Redis Cluster 是 Redis 官方从 3.0 版本开始推出的分布式解决方案。它在实现了高可用的同时，还提供了数据分片（Sharding）的能力，可以将数据自动地分布到多个节点上，从而解决了单机 Redis 的内存和并发瓶颈，实现了真正的水平扩展。

## 目录
- [集群的核心思想](#集群的核心思想)
  - [数据分片 (Sharding)](#数据分片-sharding)
  - [高可用 (High Availability)](#高可用-high-availability)
- [核心概念](#核心概念)
  - [哈希槽 (Hash Slot)](#哈希槽-hash-slot)
  - [节点 (Node)](#节点-node)
  - [Gossip 协议](#gossip-协议)
  - [MOVED 和 ASK 重定向](#moved-和-ask-重定向)
- [工作原理](#工作原理)
  - [数据分布](#数据分布)
  - [故障检测与转移](#故障检测与转移)
- [如何搭建和管理集群](#如何搭建和管理集群)
  - [准备节点](#准备节点)
  - [创建集群](#创建集群)
  - [集群伸缩](#集群伸缩)
- [客户端如何与集群交互](#客户端如何与集群交互)
- [集群的限制](#集群的限制)
- [总结](#总结)

---

## 集群的核心思想

### 数据分片 (Sharding)
Redis Cluster 将整个数据集划分为 16384 个哈希槽（hash slots）。每个键（key）通过 `CRC16(key) mod 16384` 算法计算出属于哪个哈希槽。集群中的每个主节点（master）负责管理一部分哈希槽。当客户端需要操作一个键时，它会先计算该键属于哪个槽，然后将请求发送到负责该槽的主节点上。

### 高可用 (High Availability)
集群采用了主从复制模型来实现高可用。每个主节点都可以有零个或多个从节点（replica）。当某个主节点发生故障时，集群会自动从其对应的从节点中选举一个来替代它，成为新的主节点，从而保证服务的持续性。这个过程类似于 Sentinel，但在集群内部自动完成。

## 核心概念

### 哈希槽 (Hash Slot)
这是 Redis Cluster 数据分片的基础。集群中共有 16384 (2^14) 个槽，这个数字是固定的。集群的扩容和缩容，本质上是在不同节点之间移动哈希槽的所有权。

**哈希标签 (Hash Tags)**:
为了让多个相关的键能够落入同一个哈希槽，从而支持多键操作（如事务、Lua脚本），Redis Cluster 提供了哈希标签功能。如果一个键中包含 `{}`，那么只有 `{}` 之间的部分会被用来计算哈希槽。例如，`{user:1000}:name` 和 `{user:1000}:email` 会被分配到同一个槽。

### 节点 (Node)
一个 Redis Cluster 通常由多个节点组成。每个节点都是一个运行中的 `redis-server` 实例。节点分为主节点和从节点：
-   **主节点 (Master)**: 负责处理哈希槽的读写请求，并将数据同步给自己的从节点。
-   **从节点 (Replica)**: 复制对应主节点的数据。当主节点故障时，参与选举以成为新的主节点。平时也可以分担读请求（需要客户端显式支持）。

### Gossip 协议
集群中的节点之间通过 Gossip 协议来交换信息，以维护集群的元数据（meta data）。这些信息包括：
-   节点的状态（在线、疑似下线、已下线）。
-   哈希槽的分布情况。
-   新节点的加入或离开。

Gossip 协议使得集群的节点能够以去中心化的方式进行通信，最终达成状态的一致。

### MOVED 和 ASK 重定向

由于哈希槽可能在节点间迁移，客户端可能会向错误的节点发送请求。此时，集群通过两种重定向指令来通知客户端：

1.  **`-MOVED <slot> <ip>:<port>`**:
    当客户端向一个节点发送关于某个键的命令，但该键所在的哈希槽**不归**此节点负责时，节点会返回一个 `-MOVED` 错误。这个错误告诉客户端，该槽已经**永久地**移动到了指定的 IP 和端口。智能客户端会更新本地的槽位缓存，并向正确的节点重新发送请求。

2.  **`-ASK <slot> <ip>:<port>`**:
    当一个哈希槽正在从节点 A 迁移到节点 B 的过程中，如果客户端请求的键还在节点 A，但它属于正在迁移的槽，节点 A 会返回一个 `-ASK` 错误。这个错误告诉客户端，该请求**下一次**应该去问节点 B。`-ASK` 是一个**临时性**的重定向，不会更新客户端的槽位缓存。客户端收到 `-ASK` 后，需要先向目标节点发送一个 `ASKING` 命令，然后再发送真正的操作命令。

## 工作原理

### 数据分布
-   **创建集群时**：16384 个哈希槽会被平均分配给所有初始的主节点。
-   **客户端请求**：客户端（最好是支持集群的智能客户端）会缓存一份哈希槽与节点的映射关系。当执行命令时，先在本地计算键的哈希槽，直接将请求发往对应的节点。如果本地缓存过时，通过 `MOVED` 重定向来更新缓存。

### 故障检测与转移
-   **疑似下线 (PFAIL - Possible Fail)**：当节点 A 在一段时间内（`cluster-node-timeout`）无法与节点 B 通过 Gossip 协议通信时，节点 A 会在自己的视角里将节点 B 标记为 PFAIL。
-   **已下线 (FAIL)**：当集群中超过半数的主节点都将某个主节点 X 标记为 PFAIL 时，该主节点 X 会被标记为 FAIL。这个消息会通过 Gossip 协议传播到整个集群。
-   **从节点选举**：一旦主节点被标记为 FAIL，其下属的从节点会开始准备选举。数据最新的从节点（复制偏移量最大）会发起选举，并向其他主节点请求投票。
-   **故障转移**：如果该从节点获得了超过半数主节点的投票，它就会赢得选举，升级为新的主节点，接管原来主节点的哈希槽，并开始接受写请求。

## 如何搭建和管理集群

假设需要搭建一个3主3从的集群。

### 准备节点
1.  准备6个 Redis 实例，分别在不同端口运行（如 7000-7005）。
2.  确保它们的配置文件中开启了集群模式：
    ```conf
    cluster-enabled yes
    cluster-config-file nodes.conf
    cluster-node-timeout 15000
    ```

### 创建集群
从 Redis 5.0 开始，可以使用 `redis-cli` 工具非常方便地创建集群：
```bash
# --cluster-replicas 1 表示为每个主节点创建一个从节点
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1
```
`redis-cli` 会自动分配主从角色，并均匀地分配哈希槽。

### 集群伸缩
-   **添加节点 (Resharding)**：
    1.  启动一个新的 Redis 实例。
    2.  使用 `redis-cli --cluster add-node` 将新节点加入集群（初始为主节点，但没有分配槽）。
    3.  使用 `redis-cli --cluster reshard` 从现有主节点向新节点迁移一部分哈希槽。
-   **删除节点**：
    1.  使用 `redis-cli --cluster reshard` 将要删除节点的所有哈希槽迁移到其他主节点。
    2.  使用 `redis-cli --cluster del-node` 将该空节点从集群中移除。

## 客户端如何与集群交互
-   必须使用支持 Redis Cluster 的客户端库（如 `redis-py-cluster`, `lettuce` 等）。
-   客户端在启动时，至少需要连接到集群中的一个节点。它会通过 `CLUSTER SLOTS` 命令获取整个集群的槽位映射信息并缓存起来。
-   当收到 `MOVED` 或 `ASK` 重定向时，智能客户端会自动处理，并更新缓存。

## 集群的限制
1.  **多键操作受限**：除非使用哈希标签将键强制分配到同一个槽，否则无法对多个键执行原子操作（如 `MSET`, `LPUSH` 多值, 事务, Lua脚本）。
2.  **数据库选择**：Redis Cluster 只支持使用数据库 `0`，不支持 `SELECT` 命令。
3.  **数据迁移开销**：在进行 resharding（迁移槽）时，对于包含大键的槽，迁移可能会阻塞源节点和目标节点，造成性能抖动。

## 总结
Redis Cluster 是一个强大且成熟的分布式解决方案，它通过数据分片实现了水平扩展，通过主从复制和自动故障转移实现了高可用。虽然它对多键操作等场景存在一些限制，但对于大多数需要突破单机瓶颈的应用来说，Redis Cluster 提供了一个原生、高效且易于管理的分布式缓存和存储系统。 