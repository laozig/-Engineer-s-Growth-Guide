# MongoDB 性能调优与监控

性能是任何生产数据库的关键。本指南将介绍如何监控 MongoDB 的性能、识别瓶颈，并采取措施进行优化。

## 1. 性能监控

有效的性能调优始于全面的监控。您需要了解数据库的基线性能，才能在出现问题时快速识别。

### 监控工具

- **`mongostat`**：一个命令行工具，可以实时查看 MongoDB 实例的状态，包括操作计数、内存使用情况和网络流量。
  ```bash
  mongostat --uri="mongodb://username:password@host:port"
  ```
- **`mongotop`**：一个命令行工具，用于跟踪 MongoDB 实例在每个集合上花费的时间。它可以帮助您识别哪些集合的读写活动最频繁。
  ```bash
  mongotop --uri="mongodb://username:password@host:port" 10 # 每10秒刷新一次
  ```
- **数据库分析器 (Database Profiler)**：
  - **描述**：MongoDB 内置的分析器，可以收集有关数据库操作的详细信息。您可以为整个实例或特定数据库启用它。
  - **级别**：
    - `0` (关闭): 不收集任何数据。
    - `1` (慢操作): 只记录超过 `slowms` 阈值的操作。
    - `2` (所有操作): 记录所有操作（对性能有影响，慎用）。
  - **启用分析器**：
    ```javascript
    db.setProfilingLevel(1, { slowms: 100 }) // 记录超过100ms的操作
    ```
- **MongoDB Atlas / Ops Manager / Cloud Manager**：提供丰富的可视化性能仪表板、图表和警报，是生产环境中最推荐的监控解决方案。

## 2. 索引优化

索引是 MongoDB 性能优化的核心。正确使用索引可以极大地提高查询速度。

### 识别慢查询

使用数据库分析器或日志文件来识别执行缓慢的查询。

### `explain()` 方法

`explain()` 是分析查询性能的最重要工具。它可以告诉您查询是否使用了索引、扫描了多少文档以及执行所花费的时间。

```javascript
db.users.find({ age: { $gt: 25 } }).explain("executionStats")
```

**`explain()` 输出的关键字段**：

- `executionStats.nReturned`：返回的文档数。
- `executionStats.totalKeysExamined`：扫描的索引键数。
- `executionStats.totalDocsExamined`：扫描的文档数。
- `winningPlan.stage`：
  - `COLLSCAN`：全集合扫描，性能最低。应尽量避免。
  - `IXSCAN`：索引扫描，表示查询正在使用索引。

**优化目标**：力求 `totalKeysExamined` 和 `totalDocsExamined` 的数量与 `nReturned` 的数量尽可能接近。

### 创建和选择索引

- **复合索引 (Compound Indexes)**：当查询涉及多个字段时，创建复合索引。索引字段的顺序很重要，应遵循 **ESR（Equality, Sort, Range）规则**：
  1.  **等值匹配 (Equality)** 字段放在最前面。
  2.  **排序 (Sort)** 字段次之。
  3.  **范围 (Range)** 字段放在最后。
- **覆盖查询 (Covered Queries)**：如果查询所需的所有字段都包含在索引中，MongoDB 可以直接从索引返回结果，而无需访问文档。这是最高效的查询方式。
- **删除未使用的索引**：使用 `$indexStats` 聚合阶段来识别和删除不再使用的索引，以减少写入开销和存储空间。

## 3. 硬件和拓扑结构

- **内存 (RAM)**：MongoDB 的性能在很大程度上取决于内存。WiredTiger 存储引擎会将其工作集（最常访问的数据和索引）缓存到内存中。确保您的服务器有足够的 RAM 来容纳工作集。
- **磁盘 (Disk)**：使用高性能的 SSD 来减少磁盘 I/O 延迟，特别是对于写密集型应用。
- **CPU**：虽然 MongoDB 通常不是 CPU 密集型，但复杂的聚合和排序操作可能会消耗大量 CPU 资源。
- **网络**：确保客户端和数据库之间的网络延迟尽可能低。
- **读写分离**：在读密集型应用中，可以将读操作路由到从节点（Secondary），以减轻主节点（Primary）的压力。但要注意，从节点的数据可能会有轻微延迟。

## 4. 模式设计

- **避免大文档**：过大的文档会增加内存使用和网络传输开销。MongoDB 的文档大小限制为 16MB。
- **避免大数组**：无限制增长的数组是一个反模式。如果数组可能变得很大，请考虑将其拆分到单独的集合中。
- **内嵌 vs. 引用**：根据数据的访问模式来决定是使用内嵌文档还是引用。
  - **内嵌 (Embedding)**：适用于"一对一"或"一对少"关系，且数据需要一起访问。可以减少查询次数。
  - **引用 (Referencing)**：适用于"一对多"或"多对多"关系，或者当子文档很大且不总是需要与父文档一起访问时。

## 5. 并发与连接池

- **WiredTiger 并发**：WiredTiger 存储引擎支持文档级并发控制。长时间运行的操作不会锁定整个集合。
- **连接池**：应用程序应使用连接池来管理与数据库的连接。为每个请求打开和关闭连接会带来巨大的性能开销。确保连接池的大小适合您的应用程序负载。
