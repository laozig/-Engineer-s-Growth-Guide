# MongoDB 多文档事务 (Transactions)

MongoDB 在设计之初，其核心优势之一是单个文档操作的原子性。对于许多用例，通过巧妙的数据建模（例如内嵌），可以将需要原子更新的数据组织在单个文档内，从而满足业务需求。然而，对于某些场景，必须保证对**多个文档**的更新操作要么全部成功，要么全部失败。为了应对这种需求，MongoDB 4.0 引入了对**复制集**的多文档事务支持，并在 4.2 版本中将其扩展到了**分片集群**。

## 目录
- [什么是 ACID 事务？](#什么是-acid-事务)
- [MongoDB 事务的适用场景](#mongodb-事务的适用场景)
- [如何使用事务？(会话 Session)](#如何使用事务会话-session)
  - [事务 API 的核心方法](#事务-api-的核心方法)
  - [代码示例 (Node.js)](#代码示例-nodejs)
- [事务的属性与限制](#事务的属性与限制)
  - [快照隔离 (Snapshot Isolation)](#快照隔离-snapshot-isolation)
  - [事务生命周期与超时](#事务生命周期与超时)
  - [操作限制](#操作限制)
- [事务与性能](#事务与性能)
- [结论：何时使用事务？](#结论何时使用事务)

---

## 什么是 ACID 事务？

ACID 是数据库事务正确执行的四个基本要素的缩写：
-   **原子性 (Atomicity)**: 事务中的所有操作要么全部完成，要么全部不产生任何效果。不存在部分完成的情况。
-   **一致性 (Consistency)**: 事务必须使数据库从一个有效的状态转变为另一个有效的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。
-   **隔离性 (Isolation)**: 并发执行的事务之间互不干扰。一个事务所做的修改在最终提交前，对其他事务是不可见的。
-   **持久性 (Durability)**: 一旦事务提交，其结果就是永久性的，即使系统发生故障也不会丢失。

MongoDB 的多文档事务提供了完整的 ACID 保证。

## MongoDB 事务的适用场景

**黄金法则**：如果能通过单文档原子操作解决问题，就不要轻易使用多文档事务。

典型的需要事务的场景包括：

1.  **银行转账**：在一个账户扣款，同时在另一个账户存款。这两个操作必须捆绑在一个事务中。
2.  **订单处理**：更新订单状态的同时，需要扣减多个产品的库存。
3.  **用户注册**：创建一个用户（`users` 集合）的同时，为其创建一个个人资料（`profiles` 集合）。

在这些场景中，如果其中一步操作失败，所有已完成的操作都需要回滚，以保证数据的一致性。

## 如何使用事务？(会话 Session)

在 MongoDB 中，事务是与**会话（Session）**紧密绑定的。你必须先启动一个客户端会话，然后才能在该会话内开启事务。

### 事务 API 的核心方法

这些方法通常由 MongoDB 驱动程序提供，具体语法可能略有不同：

-   `startSession()`: 创建一个会话。
-   `withTransaction(callback, options)`: 这是**推荐**的使用方式。它会自动处理事务的开始、提交和中止（回滚），并包含了重试逻辑。你只需要在回调函数中编写你的数据库操作即可。
-   `startTransaction()`: 手动开启一个事务。
-   `commitTransaction()`: 手动提交事务。
-   `abortTransaction()`: 手动中止（回滚）事务。

### 代码示例 (Node.js)

以下是一个使用 Node.js 驱动程序和 `withTransaction` 的银行转账示例：

```javascript
// 假设 client 是已连接的 MongoClient 实例
// accounts 是 db.collection("accounts")

const session = client.startSession();

try {
  // withTransaction 会自动处理 start, commit, abort
  await session.withTransaction(async () => {
    // 操作 1: 从 Alice 账户扣款 100
    await accounts.updateOne(
      { name: "Alice" },
      { $inc: { balance: -100 } },
      { session } // **关键：所有事务内的操作都必须关联 session**
    );

    // 操作 2: 向 Bob 账户存款 100
    await accounts.updateOne(
      { name: "Bob" },
      { $inc: { balance: 100 } },
      { session } // **关键：所有事务内的操作都必须关联 session**
    );
    
    // 如果在此处抛出异常，withTransaction 会自动调用 abortTransaction
    
  }, {
    readConcern: { level: 'snapshot' },
    writeConcern: { w: 'majority' }
  });

  console.log("Transaction successful!");

} catch (error) {
  console.error("Transaction failed: ", error);
} finally {
  await session.endSession(); // 结束会话
}
```

## 事务的属性与限制

### 快照隔离 (Snapshot Isolation)

MongoDB 事务提供了**快照隔离**级别。当一个事务开始时，它会获得一个数据库在特定时间点的"快照"。
-   事务中的读操作将从这个快照中读取数据，无论外部其他写操作如何修改数据，事务内部的视图都保持一致。
-   如果事务在提交时，发现它所读取或修改的数据已经被另一个已提交的事务更改，那么这个事务将会提交失败（Write Conflict），并需要重试。

### 事务生命周期与超时

-   事务中的所有操作必须在 **60 秒**内完成（默认值），这个时间可以通过 `transactionLifetimeLimitSeconds` 参数进行配置。
-   长时间运行的事务会持有锁，并消耗更多资源，应尽量避免。

### 操作限制

-   **集合操作**：你不能在事务中创建或删除集合、索引。这些应在事务外部完成。
-   **系统集合**：不能对 `config`, `admin`, `local` 数据库中的系统集合进行操作。
-   **Oplog 上限**：事务产生的所有 oplog 必须能装入一个 16MB 的 BSON 文档中。

## 事务与性能

-   **性能开销**：事务会带来额外的性能开销。因为它们需要管理会话、维护快照、持有锁，并可能因为写冲突而重试。
-   **锁**：事务在执行写操作时会获取文档级别的锁。当事务提交时，这些锁才会被释放。这意味着长时间运行的事务可能会阻塞其他操作。
-   **分片集群**：在分片集群中，事务的协调成本更高，性能影响也更大。

## 结论：何时使用事务？

1.  **首选数据模型**：尽可能通过优秀的数据建模（如内嵌）来利用单文档原子性，避免多文档事务。这是最高效的方式。
2.  **必要时使用**：当业务逻辑确实需要跨多个文档或集合的原子性保证时，事务是强大而正确的工具。
3.  **保持简短**：将事务设计得尽可能简短、快速，只包含必须在原子单元中执行的操作，以最小化性能影响和锁的持有时间。

多文档事务的引入，极大地扩展了 MongoDB 的应用场景，使其能够处理传统上只有关系型数据库才能胜任的复杂业务逻辑，同时又不失其原有的灵活性和可扩展性。 