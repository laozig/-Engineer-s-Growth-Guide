# 9. 事务与并发控制

事务和并发控制是任何健壮的关系数据库系统的核心，它们确保了即使在多个用户同时操作数据库时，数据的完整性和一致性也能得到保障。

## ACID 属性

事务是一组必须作为一个整体全部执行或全部不执行的SQL操作。一个设计良好的事务处理系统必须保证ACID属性：

- **原子性 (Atomicity)**: 事务是不可分割的最小工作单元。事务中的所有操作要么全部成功提交，要么全部失败回滚。数据库不会处于"部分完成"的状态。
- **一致性 (Consistency)**: 事务必须使数据库从一个一致性状态转变到另一个一致性状态。在事务开始和结束时，数据库的完整性约束（如外键、唯一键）必须保持满足。
- **隔离性 (Isolation)**: 一个事务的执行不能被其他并发事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- **持久性 (Durability)**: 一旦事务成功提交，它对数据库的改变就必须是永久的。即使系统后续发生崩溃，也应该能够恢复。PostgreSQL通过WAL（预写式日志）机制来保证这一点。

## 在PostgreSQL中使用事务

PostgreSQL使用以下命令来控制事务：

- **`BEGIN`** 或 **`START TRANSACTION`**: 开启一个新事务。
- **`COMMIT`**: 成功提交当前事务，使其所有更改永久生效。
- **`ROLLBACK`**: 回滚（撤销）当前事务中的所有操作，使数据库返回到事务开始前的状态。

```sql
BEGIN;

-- 假设 Eve 给 Alice 转账 5000
UPDATE employees SET salary = salary - 5000 WHERE name = 'Eve';
UPDATE employees SET salary = salary + 5000 WHERE name = 'Alice';

-- 在这里可以进行一些检查，例如，检查 Eve 的薪水是否低于某个阈值
-- 如果检查失败，可以执行 ROLLBACK

COMMIT; -- 如果一切正常，提交事务
```

## 多版本并发控制 (MVCC)

为了实现高并发和高性能，PostgreSQL没有使用传统的读/写锁模型，而是采用了**多版本并发控制 (Multi-Version Concurrency Control, MVCC)**。

**MVCC的工作原理**:
1.  **读不阻塞写，写不阻塞读**: 当一个事务需要读取数据时，它会读取该行在事务开始时的一个"快照"版本，而不会被正在修改该行的其他事务所阻塞。同样，一个写操作也不会阻塞读操作。
2.  **数据行的版本**: 当一个事务更新一行数据时，PostgreSQL不会在原地修改这行数据。相反，它会将原始行标记为"过期"，并创建一个包含新数据的新版本行。
3.  **事务可见性**: 每个事务都有一个唯一的事务ID (XID)。PostgreSQL通过比较行版本上的XID和当前事务的XID来判断哪些行对当前事务是"可见的"。
4.  **清理 (Vacuum)**: 随着时间的推移，数据库中会积累大量过期的行版本。`VACUUM` 进程（通常是自动的）负责清理这些不再对任何活动事务可见的"死行"，并回收它们占用的空间。

MVCC是PostgreSQL能够提供出色并发性能的关键，但它也要求数据库管理员理解并适当配置 `autovacuum`。

## 事务隔离级别

SQL标准定义了四种事务隔离级别，用于在"性能"和"数据一致性"之间进行权衡。PostgreSQL全部支持它们。

| 隔离级别 | 脏读 (Dirty Read) | 不可重复读 (Non-Repeatable Read) | 幻读 (Phantom Read) |
| --- | --- | --- | --- |
| **读未提交 (Read Uncommitted)** | 可能 | 可能 | 可能 |
| **读已提交 (Read Committed)** | 不允许 | 可能 | 可能 |
| **可重复读 (Repeatable Read)** | 不允许 | 不允许 | 可能 |
| **可串行化 (Serializable)** | 不允许 | 不允许 | 不允许 |

- **脏读**: 一个事务读取到另一个事务尚未提交的数据。
- **不可重复读**: 在同一个事务中，两次执行同样的查询，但得到的结果不同（因为在此期间有其他事务提交了更新）。
- **幻读**: 在同一个事务中，两次执行同样的查询，但第二次查询返回了第一次没有出现的"幻影"行（因为在此期间有其他事务提交了插入或删除）。

**PostgreSQL的默认隔离级别是 `读已提交 (Read Committed)`**。这在大多数场景下提供了性能和一致性的良好平衡。

您可以使用 `SET TRANSACTION` 命令来为当前事务设置隔离级别：
```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 你的SQL操作
COMMIT;
```

在 `可重复读 (Repeatable Read)` 级别下，PostgreSQL的MVCC快照保证了在事务期间，您看到的数据始终是事务开始时的状态，避免了不可重复读。对于幻读，PostgreSQL在 `RepeatABLE READ` 级别下也能在很大程度上防止，但要完全杜绝幻读，则需要使用最高的 `可串行化 (Serializable)` 级别，这会带来更大的性能开销。

理解ACID和MVCC是理解关系型数据库如何工作的核心。下一章，我们将介绍 [视图与物化视图](views.md) 的概念。 